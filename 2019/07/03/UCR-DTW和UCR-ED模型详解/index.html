<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="google-site-verification" content="iejSa-LmOb9d1GguAcEsQNUsQviccOieHkuG1c1E2YI">



  <meta name="msvalidate.01" content="83768A52AE58ADF203609FEF9C55FF47">












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="DTW 动态规划 相似度度量,">










<meta name="description" content="Searching and mining trillions of time series subsequences under dynamic time warping– Rakthanmanon et al. SIGKDD 2012  在这篇论文中，作者主要是针对DTW算法提出一系列的优化策略。本论文提出的UCR-DTW模型可以在低配设备上实时地使用DTW算法在大规模数据集上进行高效的时间序">
<meta name="keywords" content="DTW 动态规划 相似度度量">
<meta property="og:type" content="article">
<meta property="og:title" content="UCR-DTW和UCR-ED模型详解">
<meta property="og:url" content="https://jozeelin.github.io/2019/07/03/UCR-DTW和UCR-ED模型详解/index.html">
<meta property="og:site_name" content="Jozee&#39;s技术博客">
<meta property="og:description" content="Searching and mining trillions of time series subsequences under dynamic time warping– Rakthanmanon et al. SIGKDD 2012  在这篇论文中，作者主要是针对DTW算法提出一系列的优化策略。本论文提出的UCR-DTW模型可以在低配设备上实时地使用DTW算法在大规模数据集上进行高效的时间序">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://jozeelin.github.io/2019/07/03/UCR-DTW和UCR-ED模型详解/image/ucr-ed-1.png">
<meta property="og:image" content="https://jozeelin.github.io/2019/07/03/UCR-DTW和UCR-ED模型详解/image/ucr-dtw-1.png">
<meta property="og:image" content="https://jozeelin.github.io/2019/07/03/UCR-DTW和UCR-ED模型详解/image/ucr-dtw-2.png">
<meta property="og:image" content="https://jozeelin.github.io/2019/07/03/UCR-DTW和UCR-ED模型详解/image/ucr-lower-bound-2.png">
<meta property="og:image" content="https://jozeelin.github.io/2019/07/03/UCR-DTW和UCR-ED模型详解/image/ucr-ed-2.png">
<meta property="og:image" content="https://jozeelin.github.io/2019/07/03/UCR-DTW和UCR-ED模型详解/image/ucr-dtw-3.png">
<meta property="og:image" content="https://jozeelin.github.io/2019/07/03/UCR-DTW和UCR-ED模型详解/image/ucr-normalization-1.png">
<meta property="og:image" content="https://jozeelin.github.io/2019/07/03/UCR-DTW和UCR-ED模型详解/image/ucr-normalization-2.png">
<meta property="og:image" content="https://jozeelin.github.io/2019/07/03/UCR-DTW和UCR-ED模型详解/image/ucr-normalization-3.png">
<meta property="og:image" content="https://jozeelin.github.io/2019/07/03/UCR-DTW和UCR-ED模型详解/image/ucr-normalization-4.png">
<meta property="og:image" content="https://jozeelin.github.io/2019/07/03/UCR-DTW和UCR-ED模型详解/image/ucr-order-1.png">
<meta property="og:image" content="https://jozeelin.github.io/2019/07/03/UCR-DTW和UCR-ED模型详解/image/ucr-LB-1.png">
<meta property="og:image" content="https://jozeelin.github.io/2019/07/03/UCR-DTW和UCR-ED模型详解/image/ucr-lower-bound-1.png">
<meta property="og:image" content="https://jozeelin.github.io/2019/07/03/UCR-DTW和UCR-ED模型详解/image/random-walk.png">
<meta property="og:image" content="https://jozeelin.github.io/2019/07/03/UCR-DTW和UCR-ED模型详解/image/ucr-expiriment-2.png">
<meta property="og:updated_time" content="2019-07-27T08:53:31.947Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="UCR-DTW和UCR-ED模型详解">
<meta name="twitter:description" content="Searching and mining trillions of time series subsequences under dynamic time warping– Rakthanmanon et al. SIGKDD 2012  在这篇论文中，作者主要是针对DTW算法提出一系列的优化策略。本论文提出的UCR-DTW模型可以在低配设备上实时地使用DTW算法在大规模数据集上进行高效的时间序">
<meta name="twitter:image" content="https://jozeelin.github.io/2019/07/03/UCR-DTW和UCR-ED模型详解/image/ucr-ed-1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://jozeelin.github.io/2019/07/03/UCR-DTW和UCR-ED模型详解/">





  <title>UCR-DTW和UCR-ED模型详解 | Jozee's技术博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jozee's技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jozeelin.github.io/2019/07/03/UCR-DTW和UCR-ED模型详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jozee">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jozee's技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">UCR-DTW和UCR-ED模型详解</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-03T19:42:03+08:00">
                2019-07-03
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-07-27T16:53:31+08:00">
                2019-07-27
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/时间序列/" itemprop="url" rel="index">
                    <span itemprop="name">时间序列</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/07/03/UCR-DTW和UCR-ED模型详解/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/07/03/UCR-DTW和UCR-ED模型详解/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
          <span id="busuanzi_container_page_pv">
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
            <i class="fa fa-eye"></i>
            </span>
            阅读量: <span id="busuanzi_value_page_pv"></span>次
          </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p><a href="http://www.cs.ucr.edu/~eamonn/SIGKDD_trillion.pdf" target="_blank" rel="noopener">Searching and mining trillions of time series subsequences under dynamic time warping</a>– Rakthanmanon et al. <em>SIGKDD 2012</em></p>
</blockquote>
<p>在这篇论文中，作者主要是针对DTW算法提出一系列的优化策略。本论文提出的UCR-DTW模型可以在低配设备上实时地使用DTW算法在大规模数据集上进行高效的时间序列相似性搜索而无需对时间序列建立索引。</p>
<h2 id="DTW-Dynamic-Time-Warping-及已知的优化策略"><a href="#DTW-Dynamic-Time-Warping-及已知的优化策略" class="headerlink" title="DTW(Dynamic Time Warping)及已知的优化策略"></a>DTW(Dynamic Time Warping)及已知的优化策略</h2><p>计算两个时间序列 Q和C之间的相似度，常用的度量方法是欧式距离(ED)，计算公式如下图(1-1)所示：</p>
<p><img src="image/ucr-ed-1.png" alt="ucr-ed-1"></p>
<p>从上图可以看到欧式距离的局限性：欧式距离通过建立两个序列之间的一一对应关系，使得Q和C之间的波峰没有对齐，因此计算得到的序列相似度存在较大的偏差。DTW 算法则可以很好的解决这个问题。</p>
<p>大部分情况下，两个序列整体上具有非常相似的形状，但是这些形状在时间轴上并不是对齐的。所以在计算两个序列的相似度之前，需要将其中一个(或者两个)序列在时间轴上进行warping，使得两个序列波峰更好的对齐。</p>
<p>DTW就是实现这种warping的一种有效方法。换句话说，DTW算法通过找到两个序列之间的另外一种非一一对应的映射关系，这个映射关系也称为<strong>warping path</strong>。以上面的Q,C为例，得到的对应关系如下图(1-2)中的灰色线段所示:</p>
<p><img src="image/ucr-dtw-1.png" alt="ucr-dtw-1"></p>
<p>DTW算法的求解过程的直观理解为构建一个nxn的矩阵(此处假设Q和C的时间序列长度都为n，矩阵中的元素(i,j)表示序列Q的时间点<script type="math/tex">q_i</script> 和序列C的时间点<script type="math/tex">c_j</script>之间的欧式距离）目标是在矩阵中找到一条从(0,0)到(n,n)的路径，使得路径上的所有元素之和最小。如下图(1-3)所示，红色标识的路径即为warping path：</p>
<p><img src="image/ucr-dtw-2.png" alt="ucr-dtw-2"></p>
<p>图(1-2)和图(1-3)是等价的，都是表示了Q和C之间的映射关系。</p>
<blockquote>
<p>欧式距离相当于DTW的特例，对应的warping path为从矩阵左下角到右上角的对角线。</p>
</blockquote>
<p>目前已知的DTW顺序搜索的四种优化方法如下:</p>
<ol>
<li><p>去掉平方根计算</p>
</li>
<li><p>通过使用lower bounds来剪枝，因为lower bounds的计算时间复杂度都小于DTW的时间复杂度。比如：</p>
<ol>
<li><p>LB_{\textrm{Kim}}FL$$的时间复杂度为O(1)</p>
<p>本文在实现时，由于对时间序列进行标准化后，时间序列数据中的最大和最小值对于整个lower bound距离贡献较小，因此，去掉原来LB_kim算法(时间复杂度为O(n))中提取的四个特征点中的最大值和最小值，使得时间复杂度降为O(1)。但是，实现中为了使此策略发挥最大作用，作者还提取了第2,3和倒数第2,3个时间点，来进行级联剪枝。(详情参考算法实现lb_kim_hierarchy方法)</p>
</li>
<li><p><script type="math/tex">LB_{\textrm{Keogh}}</script>的时间复杂度为O(n)</p>
<p><img src="image/ucr-lower-bound-2.png" alt="ucr-dtw-3"></p>
</li>
</ol>
</li>
<li><p>Early Abandoning of ED and <script type="math/tex">LB_{\textrm{Keogh}}</script></p>
<blockquote>
<p>基于这条优化策略，作者提出的Reorder early abandoning可以进一步降低计算成本。</p>
</blockquote>
<p>即在计算ED或者<script type="math/tex">LB_{\textrm{Keogh}}</script>的时候，如果当前的两个序列的时间点(1,k)(注：k&lt;=|Q|)之间的差值平方之和，大于当前两个序列最小距离值best-so-far，那么可以提前结束Q和C是否相似的判断。计算过程如下图(1-4)所示：</p>
<p><img src="image/ucr-ed-2.png" alt="ucr-dtw-3"></p>
</li>
<li><p>Early Abandoning of DTW </p>
<p>计算完整的<script type="math/tex">LB_{\textrm{Keogh}}</script>的值，仍然需要计算完整的DTW的值，我们可以通过利用部分的<script type="math/tex">LB_{\textrm{Keogh}}</script> 的值来减少DTW的计算量。</p>
<p>比如，先从左到右计算时间点[1,k]的DTW值，然后在时间点[k+1,n]，复用前面计算好的<script type="math/tex">LB_{\textrm{Keogh}}</script> 值。最终得到的距离值依然为完整的DTW值的lower bound。这样的话，我们就可以使用stop early策略，每计算当前时间点的DTW值，就可以复用前面计算好的<script type="math/tex">LB_{\textrm{Keogh}}</script>来获得整个子序列的lower bound值。</p>
<p>通过比较这个lower bound和当前最小距离值best-so-far进行比较，如果当前的lower bound值大于best-so-far，那么可以提前结束DTW的计算。这种方式的直观表示如下图(1-5)：</p>
<p><img src="image/ucr-dtw-3.png" alt="ucr-dtw-3"></p>
</li>
</ol>
<p> 以上，介绍完了前人对DTW的四种优化方案。</p>
<p>还有一种已知的提升DTW的计算速度的策略即使用多核计算资源。</p>
<h2 id="UCR-Suite-的优化策略"><a href="#UCR-Suite-的优化策略" class="headerlink" title="UCR Suite 的优化策略"></a>UCR Suite 的优化策略</h2><h3 id="相关概念及定义"><a href="#相关概念及定义" class="headerlink" title="相关概念及定义"></a>相关概念及定义</h3><p>定义1:时间序列T是一个有序列表：<script type="math/tex">T=t_1,t_2,\cdots,t_m</script>。然而源数据是一个很长的时间序列，我们最终需要把它与一个更短的子序列进行相似度比较。</p>
<p>定义2: 子序列<script type="math/tex">T_{i,k}</script>是时间序列T中的一个子序列，它起始于<script type="math/tex">t_i</script>，长度为k，即<script type="math/tex">T_{i,k}=t_i,t_{i+1},\cdots,t_{i+k+1}</script>。<script type="math/tex">1\le i \le m-k+1</script>。</p>
<p>这里，我们把<script type="math/tex">T_{i,k}</script>记为C，作为与query Q比较相似的候选子序列。令Q的长度为|Q|=n。</p>
<p>定义3:Q和C之间的欧式距离(|Q|=|C|)定义为 (公式1)：</p>
<script type="math/tex; mode=display">
ED(Q,C) = \sqrt{\sum_{i=1}^n (q_i-c_i)^2}</script><p>路径P的第t个元素定义为<script type="math/tex">p_t=(i,j)_t</script>，则我们可以把warping path表示为 (公式2)：</p>
<script type="math/tex; mode=display">
P=p_1,p_2,\cdots,p_t,\cdots,p_T,n\le T\le 2n-1</script><h3 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h3><ol>
<li><p>Early Abandoning Z-normalization</p>
<p>在计算DTW距离之前都需要对Q和C进行标准化处理，但是对整个数据集进行标准化的复杂度太高了，因此这里使用online Z-normalization，这样的话就可以采用early stop的策略来提前结束normalization的计算。</p>
<p>首先计算序列C的均值和方差的公式如下所示(公式3)：</p>
<p><img src="image/ucr-normalization-1.png" alt="ucr-normalization-1"></p>
<p>当使用online Z-normalization的时候，当前遍历到源序列T中的第k个时间点，所计算得到的时间点元素累加和以及时间点元素的平方累加和表示为(公式4)：</p>
<script type="math/tex; mode=display">
\textrm{sum}_k = \sum_{i=1}^k x_i ,\textrm{sum}_k^2 = \sum_{i=1}^k x_i^2</script><p>那么对于k-m+1 到k之间的这m个时间点对应的均值和方差的计算公式如下所示(公式5)：</p>
<p><img src="image/ucr-normalization-2.png" alt="ucr-normalization-2"></p>
<p>图示详解如下图(1-6) 所示：</p>
<p><img src="image/ucr-normalization-3.png" alt="ucr-normalization-3"></p>
<p>所以，基于online Z-normalization的abandon normalization early策略伪代码如下图(1-7)所示：</p>
<p><img src="image/ucr-normalization-4.png" alt="ucr-normalization-4"></p>
<blockquote>
<p>论文中，作者提到此处存在浮点计算误差累加的问题，这里通过每比对完100万子序列，就进行一次完整的Z-normalization，进而消除误差累加的问题。</p>
</blockquote>
</li>
<li><p>Reorder early abandoning</p>
<p>前面early abandoning策略的计算方式都是从子序列的第一个时间点开始，自左向右进行计算的。本文提出一种策略是先快速找到Q和C之间差值之和最大的子序列，然后根据它来判断这个子序列是否大于best-so-far值，从而可达到降低计算成本的目的。这两种顺序的计算成本对比如下图(1-8)所示：</p>
<p><img src="image/ucr-order-1.png" alt="ucr-order-1"></p>
<p>左图表示从左到右的顺序计算差值，它需要计算9个时间步才能判断是否提前结束，而右图找到一个新的计算顺序，这时候只需要计算5个时间步就能判断是否提前结束。</p>
<p>那么，现在的问题就变成了，如何找到这些差值之和最大的子序列？</p>
<blockquote>
<p>这里有一个疑问，找到的这些子序列是否是连续的？</p>
</blockquote>
<p>本文中的做法是，首先对被Z-normalization 处理过的Q序列所有时间点元素的绝对值进行排序，这样做的理论依据是，在进行DTW获取序列之间的距离时，<script type="math/tex">q_i</script> 可以对应多个序列C中的时间点。进行z-normalization后的C序列服从高斯分布，意味着均值为0，因此，距离均值0最远的<script type="math/tex">q_i</script>对距离值贡献最大，因此对z-normalizated Q序列的绝对值进行排序，从而可以快速差值之和最大的子序列。</p>
<blockquote>
<p>作者通过实验证明，使用这样的方式找到计算顺序与真实的最好计算顺序的相关度为0.999。</p>
</blockquote>
</li>
<li><p>Reversing the query/data role in <script type="math/tex">LB_{\textrm{Keogh}}</script></p>
<p>基于Q，使用<script type="math/tex">LB_{\textrm{Keogh}}EQ</script>来进行剪枝，这里只需要对Q计算一次的U和L，从而可以节省很多时间和空间开销；如果全部采用<script type="math/tex">LB_{\textrm{Keogh}}EC</script>来进行剪枝，基于每一个C，计算U和L，那么会增加很多的计算成本。</p>
<p>因此，<script type="math/tex">LB_{\textrm{Keogh}}EC</script>策略是可选项，只有当<script type="math/tex">LB_{\textrm{Keogh}}EQ</script>剪枝效果不太理想的时候，可以“just-in-time” 的策略来使用<script type="math/tex">LB_{\textrm{Keogh}}EC</script>来辅助<script type="math/tex">LB_{\textrm{Keogh}}EQ</script>提高剪枝效率，从而大大降低空间开销。对于<script type="math/tex">LB_{\textrm{Keogh}}EC</script>的时间开销，可以通过剪枝来降低完整DTW的时间开销来抵消掉。对两种计算策略的直观理解如下图(1-9)所示：</p>
<p><img src="image/ucr-LB-1.png" alt="ucr-LB-1"></p>
</li>
<li><p>Use cascading lower bounds</p>
<p>目前存在很多种lower bound的计算方式。每一种lower bound都可以用于对DTW进行剪枝而且时间复杂度可估计。截止目前为止，至少有18种lower bound机制，作者把它们都实现了一遍，然后分别在50个不同的数据集上进行测试和对比，得到的结果如下图(1-10)所示：</p>
<p><img src="image/ucr-lower-bound-1.png" alt="ucr-lower-bound-1"></p>
<p>根据以上实验结果，作者通过级联各种lower bound的方式来进行ED和DTW进行剪枝：</p>
<p>首先，使用时间复杂度为O(1) 的<script type="math/tex">LB_{\textrm{Kim}}FL</script>，这样可以过滤掉很多的candidate subsequence，</p>
<p>接着，基于Q，使用<script type="math/tex">LB_{\textrm{Keogh}}EQ</script>来进行剪枝，</p>
<p>如果，<script type="math/tex">LB_{\textrm{Keogh}}EQ</script>剪枝效果不太理想的时候，使用<script type="math/tex">LB_{\textrm{Keogh}}EC</script>来辅助<script type="math/tex">LB_{\textrm{Keogh}}EQ</script>提高剪枝效率，</p>
<p>最后，如果以上的剪枝策略全部失效，则依然可以通过early abandoning 来计算完整DTW</p>
<p>实验证明，上面使用的每一个lower bound策略都能帮助提升DTW的速度，去掉任意一个lower bound策略都会使得搜索速度加倍。在大规模搜索中，以上的剪枝策略可以节省99.9999%的DTW算法的时间开销。</p>
</li>
</ol>
<h2 id="实验结果分析"><a href="#实验结果分析" class="headerlink" title="实验结果分析"></a>实验结果分析</h2><p>论文中，针对以下这几种实现方式进行性能的比较分析：</p>
<ol>
<li>Naive:每个子序列都是从零开始归一化z的。每一步都使用完整的欧氏距离或DTW。 (大约有2/3的文章是基于这种思想来进行相似度计算的)</li>
<li>State-of-the-art: 当前最好的模型基于Z-normalization,early abandoning以及使用lower bound来辅助完整DTW计算这些策略来实现的。(大约有1/3的文章基于这种思想来进行相似度计算的)</li>
<li>UCR Suite</li>
<li><p>GOd’s ALgorithm (GOAL)  直接基于均值、方差来进行比较计算相似度的，时间复杂度为O(1)</p>
<p>GOAL模型相当于所有解决长度未知无限制的序列搜索问题的最快模型的一个baseline model。</p>
</li>
</ol>
<p>在用于对比实验的4个模型都是使用UCR Suite的代码，模型之间的区别只在于把相应的加速代码注释掉而已。</p>
<h3 id="基于随机生成数据集的实验效果对比"><a href="#基于随机生成数据集的实验效果对比" class="headerlink" title="基于随机生成数据集的实验效果对比"></a>基于随机生成数据集的实验效果对比</h3><p><img src="image/random-walk.png" alt="random-walk"></p>
<p>由上图可以看到，对于128长度的query，SOFA和UCR Suite算法集之间的性能差异很大。</p>
<h3 id="不同长度query的实验对比"><a href="#不同长度query的实验对比" class="headerlink" title="不同长度query的实验对比"></a>不同长度query的实验对比</h3><p>接下来，看看对于不同长度query，这几种模型的性能对比情况：</p>
<p><img src="image/ucr-expiriment-2.png" alt="ucr-expiriment-2"></p>
<h2 id="UCR-DTW-python实现"><a href="#UCR-DTW-python实现" class="headerlink" title="UCR-DTW python实现"></a>UCR-DTW python实现</h2><p>UCR-DTW应用了以上所有的优化策略</p>
<p>GitHub:<a href="https://github.com/JozeeLin/ucr-suite-python" target="_blank" rel="noopener">ucr-suite-python</a></p>
<h2 id="UCR-ED-python-实现"><a href="#UCR-ED-python-实现" class="headerlink" title="UCR-ED python 实现"></a>UCR-ED python 实现</h2><p>UCR-ED 应用的优化策略为：</p>
<ol>
<li>Early Abandoning of ED </li>
<li>Reorder early abandoning</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UCR_ED</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,input_file, query_file,m=<span class="number">128</span>)</span>:</span></span><br><span class="line">        self.fp = open(input_file,<span class="string">'r'</span>)</span><br><span class="line">        self.qp = open(query_file,<span class="string">'r'</span>)</span><br><span class="line">        self.m = m <span class="comment">#length of query</span></span><br><span class="line">        self.Q = [<span class="literal">None</span>]*self.m<span class="comment">#query array</span></span><br><span class="line">        self.T = [<span class="number">0.0</span>]*(self.m*<span class="number">2</span>)<span class="comment">#array of current data</span></span><br><span class="line">        self.order = [] <span class="comment">#ordering of query by |z(q_i)|</span></span><br><span class="line">        self.bsf = float(<span class="string">'inf'</span>)</span><br><span class="line">        self.loc = <span class="number">0</span> <span class="comment">#answer:location of the best-so-far match</span></span><br><span class="line">        </span><br><span class="line">        self.ex,self.ex2,self.mean,self.std=<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span></span><br><span class="line">        <span class="comment">#用于统计运行时间</span></span><br><span class="line">        self.t1 = time.time()</span><br><span class="line">        self.t2 = <span class="number">0.0</span></span><br><span class="line">        </span><br><span class="line">        self.Q_normalize()</span><br><span class="line">            </span><br><span class="line">        <span class="comment">#Sort the query data</span></span><br><span class="line">        self.sort_query_order()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#read data file, one value at a time</span></span><br><span class="line">        ex = <span class="number">0.0</span></span><br><span class="line">        ex2 = <span class="number">0.0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                line = self.line_to_float(next(self.fp))</span><br><span class="line">                ex += line</span><br><span class="line">                ex2 += line*line</span><br><span class="line">                self.T[i%m] = line</span><br><span class="line">                self.T[(i%m)+m] = line</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># if there is enough data in T, the ED distance can be calculated</span></span><br><span class="line">            <span class="keyword">if</span> i&gt;=m<span class="number">-1</span>:</span><br><span class="line">                <span class="comment">#the current starting location of T</span></span><br><span class="line">                j = (i+<span class="number">1</span>)%m</span><br><span class="line">                <span class="comment">#Z-norm(T[i]) will be calculated on the fly</span></span><br><span class="line">                mean = ex/self.m</span><br><span class="line">                std = ex2/self.m</span><br><span class="line">                std = math.sqrt(std-mean*mean)</span><br><span class="line"></span><br><span class="line">                <span class="comment">#Calculate ED distance</span></span><br><span class="line">                dist = self.distance(self.Q, self.T, j, self.m, mean, std, self.order, self.bsf)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> dist&lt;self.bsf:</span><br><span class="line">                    self.bsf = dist</span><br><span class="line">                    self.loc = i-m+<span class="number">1</span></span><br><span class="line">                ex -= self.T[j]</span><br><span class="line">                ex2 -= self.T[j]*self.T[j]</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        self.fp.close()</span><br><span class="line"></span><br><span class="line">        self.t2 = time.time()</span><br><span class="line">        </span><br><span class="line">        print(<span class="string">"Location: "</span>, self.loc)</span><br><span class="line">        print(<span class="string">"Distance: "</span>,math.sqrt(self.bsf))</span><br><span class="line">        print(<span class="string">"Data Scanned: "</span>, i)</span><br><span class="line">        print(<span class="string">"Total Execution Time: "</span>,(self.t2-self.t1),<span class="string">' sec'</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">line_to_float</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> ConvertELogStrToValue(s.strip())[<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sort_query_order</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.Q_tmp = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.m):</span><br><span class="line">            self.Q_tmp[i] = self.Q[i]</span><br><span class="line">        self.Q_tmp = dict(sorted(self.Q_tmp.items(),key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>]))</span><br><span class="line">        <span class="comment">#also create another arrays for keeping sorted envelop</span></span><br><span class="line">        self.order = list(self.Q_tmp.keys())</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Q_normalize</span><span class="params">(self)</span>:</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        ex = <span class="number">0.0</span></span><br><span class="line">        ex2 = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;self.m:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                line = self.line_to_float(next(self.qp))</span><br><span class="line">                ex += line</span><br><span class="line">                ex2 += line*line</span><br><span class="line">                self.Q[i] = line</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        self.qp.close()</span><br><span class="line">        </span><br><span class="line">        mean = ex/self.m</span><br><span class="line">        std = ex2/self.m</span><br><span class="line">        std = math.sqrt(std-mean*mean)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#Do z-normalization on query data</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.m):</span><br><span class="line">            self.Q[i] = (self.Q[i]-mean)/std</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">distance</span><span class="params">(self,Q,T,j,m,mean,std,order,bsf)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        Main function for calculating ED distance between the query Q and current data T</span></span><br><span class="line"><span class="string">        Q is already sorted by absolute z-normalization value |Z-normalize(Q[i])|</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        distance_sum = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">if</span> distance_sum&gt;=bsf:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            x = (T[order[i]+j]-mean)/std</span><br><span class="line">            distance_sum += (x-Q[i])*(x-Q[i])</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> distance_sum</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://blog.acolyer.org/2016/05/11/searching-and-mining-trillions-of-time-series-subsequences-under-dynamic-time-warping/" target="_blank" rel="noopener">Searching and mining trillions -blog</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/39450321" target="_blank" rel="noopener">时间序列的搜索</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/32849741" target="_blank" rel="noopener">DTW(Dynamic Time Warping)动态时间规整</a></li>
<li><a href="https://nbviewer.jupyter.org/github/alexminnaar/time-series-classification-and-clustering/blob/master/Time%20Series%20Classification%20and%20Clustering.ipynb" target="_blank" rel="noopener">Time Series Classification and Clustering</a></li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/DTW-动态规划-相似度度量/" rel="tag"># DTW 动态规划 相似度度量</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/07/01/GloVe模型的原理与实现/" rel="next" title="GloVe模型的原理与实现">
                <i class="fa fa-chevron-left"></i> GloVe模型的原理与实现
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/07/19/XGBoost/" rel="prev" title="XGBoost论文解读">
                XGBoost论文解读 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">jozee</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">44</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#DTW-Dynamic-Time-Warping-及已知的优化策略"><span class="nav-number">1.</span> <span class="nav-text">DTW(Dynamic Time Warping)及已知的优化策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UCR-Suite-的优化策略"><span class="nav-number">2.</span> <span class="nav-text">UCR Suite 的优化策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#相关概念及定义"><span class="nav-number">2.1.</span> <span class="nav-text">相关概念及定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优化策略"><span class="nav-number">2.2.</span> <span class="nav-text">优化策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实验结果分析"><span class="nav-number">3.</span> <span class="nav-text">实验结果分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基于随机生成数据集的实验效果对比"><span class="nav-number">3.1.</span> <span class="nav-text">基于随机生成数据集的实验效果对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不同长度query的实验对比"><span class="nav-number">3.2.</span> <span class="nav-text">不同长度query的实验对比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UCR-DTW-python实现"><span class="nav-number">4.</span> <span class="nav-text">UCR-DTW python实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UCR-ED-python-实现"><span class="nav-number">5.</span> <span class="nav-text">UCR-ED python 实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料"><span class="nav-number">6.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jozee</span>

  
</div>
<div class="busuanzi_count">
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
    </script>
    <span> 本站访客数:<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
    <span>本站总访问量:<span id="busuanzi_value_site_pv"></span>次</span>
</div>









        






        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://jozeelin.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://jozeelin.github.io/2019/07/03/UCR-DTW和UCR-ED模型详解/';
          this.page.identifier = '2019/07/03/UCR-DTW和UCR-ED模型详解/';
          this.page.title = 'UCR-DTW和UCR-ED模型详解';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://jozeelin.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  





  

  

  

  
  

  

  

  

</body>
</html>
