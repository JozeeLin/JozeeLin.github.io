<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="google-site-verification" content="iejSa-LmOb9d1GguAcEsQNUsQviccOieHkuG1c1E2YI">



  <meta name="msvalidate.01" content="83768A52AE58ADF203609FEF9C55FF47">












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="判别模型,标注模型,条件随机场,">










<meta name="description" content="条件随机场(CRF)是给定一组输入随机变量条件下另一组输出随机变量的条件概率分布模型。其特点是假设输出随机变量构成马尔科夫随机场。 本章主要讨论条件随机场在标注问题中的应用，即主要讲述线性链(linear chain)条件随机场。 问题描述:由输入序列对输出序列预测的判别模型，形式为对数线性模型；学习方法：极大似然估计或正则化的极大似然估计。 本章首先介绍概率无向图模型，然后叙述条件随机场的定义和">
<meta name="keywords" content="判别模型,标注模型,条件随机场">
<meta property="og:type" content="article">
<meta property="og:title" content="条件随机场">
<meta property="og:url" content="https://jozeelin.github.io/2019/06/14/条件随机场/index.html">
<meta property="og:site_name" content="Jozee&#39;s技术博客">
<meta property="og:description" content="条件随机场(CRF)是给定一组输入随机变量条件下另一组输出随机变量的条件概率分布模型。其特点是假设输出随机变量构成马尔科夫随机场。 本章主要讨论条件随机场在标注问题中的应用，即主要讲述线性链(linear chain)条件随机场。 问题描述:由输入序列对输出序列预测的判别模型，形式为对数线性模型；学习方法：极大似然估计或正则化的极大似然估计。 本章首先介绍概率无向图模型，然后叙述条件随机场的定义和">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://jozeelin.github.io/2019/06/14/条件随机场/image/ch14-1.png">
<meta property="og:image" content="https://jozeelin.github.io/2019/06/14/条件随机场/image/ch14-2.png">
<meta property="og:image" content="https://jozeelin.github.io/2019/06/14/条件随机场/image/ch14-3.png">
<meta property="og:updated_time" content="2019-08-24T10:54:24.395Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="条件随机场">
<meta name="twitter:description" content="条件随机场(CRF)是给定一组输入随机变量条件下另一组输出随机变量的条件概率分布模型。其特点是假设输出随机变量构成马尔科夫随机场。 本章主要讨论条件随机场在标注问题中的应用，即主要讲述线性链(linear chain)条件随机场。 问题描述:由输入序列对输出序列预测的判别模型，形式为对数线性模型；学习方法：极大似然估计或正则化的极大似然估计。 本章首先介绍概率无向图模型，然后叙述条件随机场的定义和">
<meta name="twitter:image" content="https://jozeelin.github.io/2019/06/14/条件随机场/image/ch14-1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://jozeelin.github.io/2019/06/14/条件随机场/">





  <title>条件随机场 | Jozee's技术博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jozee's技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jozeelin.github.io/2019/06/14/条件随机场/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jozee">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jozee's技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">条件随机场</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-14T17:49:28+08:00">
                2019-06-14
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-08-24T18:54:24+08:00">
                2019-08-24
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/机器学习/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/06/14/条件随机场/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/06/14/条件随机场/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
          <span id="busuanzi_container_page_pv">
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
            <i class="fa fa-eye"></i>
            </span>
            阅读量: <span id="busuanzi_value_page_pv"></span>次
          </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>条件随机场(CRF)是给定一组输入随机变量条件下另一组输出随机变量的条件概率分布模型。其特点是假设输出随机变量构成马尔科夫随机场。</p>
<p>本章主要讨论条件随机场在标注问题中的应用，即主要讲述<strong>线性链(linear chain)条件随机场</strong>。</p>
<p>问题描述:由输入序列对输出序列预测的判别模型，形式为<strong>对数线性模型</strong>；学习方法：极大似然估计或正则化的极大似然估计。</p>
<p>本章首先介绍概率无向图模型，然后叙述条件随机场的定义和各种表示方法，最后介绍条件随机场的3个基本问题:概率计算问题，学习问题、预测问题。</p>
<h2 id="14-1-概率无向图模型"><a href="#14-1-概率无向图模型" class="headerlink" title="14.1 概率无向图模型"></a>14.1 概率无向图模型</h2><p>概率无向图模型(又称为马尔科夫随机场)是一个可以由<strong>无向图</strong>表示的<strong>联合概率分布</strong>。</p>
<p>本节首先叙述概率无向图模型的定义，然后介绍概率无向图模型的因子分解。</p>
<h3 id="14-1-1-模型定义"><a href="#14-1-1-模型定义" class="headerlink" title="14.1.1 模型定义"></a>14.1.1 模型定义</h3><p>概率图模型是由图表示的概率分布。</p>
<blockquote>
<p>设有联合概率分布P(Y)，<script type="math/tex">Y \in \mathcal{Y}</script>是一组随机变量。由无向图<script type="math/tex">G=(V,E)</script>表示概率分布P(Y)，即在图G中，结点<script type="math/tex">v \in V</script>表示一个随机变量<script type="math/tex">Y_v</script>，<script type="math/tex">Y=(Y_v)_{v\in V}</script>；边<script type="math/tex">e \in E</script>表示随机变量之间的概率依赖关系。</p>
</blockquote>
<p>给定一个联合概率分布<script type="math/tex">P(Y)</script>和表示它的无向图G。首先定义无向图表示的随机变量之间存在的<strong>成对马尔科夫性</strong>、<strong>局部马尔科夫性</strong>和<strong>全局马尔科夫性</strong>。</p>
<p><strong>成对马尔科夫性</strong>：设u和v是无向图G中任意两个没有边连接的结点，结点u和v分别对应随机变量<script type="math/tex">Y_u</script>和<script type="math/tex">Y_v</script>。其他所有结点为O，对应的随机变量组是<script type="math/tex">Y_O</script>。<strong>成对马尔科夫性是指给定随机变量组<script type="math/tex">Y_O</script>的条件下，随机变量<script type="math/tex">Y_u</script>和<script type="math/tex">Y_v</script>是条件独立的</strong>，即</p>
<script type="math/tex; mode=display">
P(Y_u,Y_v|Y_O)=P(Y_u|Y_O)P(Y_v|Y_O) \ (14.1)</script><p><strong>局部马尔科夫性</strong>：设<script type="math/tex">v \in V</script>是无向图G中任意一个结点，W是与v有边连接的所有结点，O是v，W以外的其他所有结点。v表示的随机变量是<script type="math/tex">Y_v</script>，W表示的随机变量组是<script type="math/tex">Y_W</script>，O表示的随机变量组是<script type="math/tex">Y_O</script>。<strong>局部马尔科夫性是指在给定随机变量组<script type="math/tex">Y_W</script>的条件下，随机变量<script type="math/tex">Y_v</script>与随机变量组<script type="math/tex">Y_O</script>是独立的</strong>。即</p>
<script type="math/tex; mode=display">
P(Y_v,Y_O|Y_W) = P(Y_v|Y_W)P(Y_O|Y_W) \ (14.2)</script><p>在<script type="math/tex">P(Y_O|Y_W)>0</script>时，等价地，</p>
<script type="math/tex; mode=display">
P(Y_v|Y_W) = P(Y_v|Y_W,Y_O) \ (14.3)</script><p>如下图所示，表示了局部马尔科夫性:</p>
<p><img src="image/ch14-1.png" alt="ch14-1"></p>
<p><strong>全局马尔科夫性</strong>：设结点集合A,B是在无向图G中被结点集合C分开的任意结点集合。<strong>全局马尔科夫性是指给定随机变量组<script type="math/tex">Y_C</script>条件下随机变量组<script type="math/tex">Y_A</script>和<script type="math/tex">Y_B</script>是条件独立的</strong>，即</p>
<script type="math/tex; mode=display">
P(Y_A,Y_B|Y_C) = P(Y_A|Y_C)P(Y_B|Y_C) \ (14.4)</script><p>如下图所示，结点集合A,B和C所对应的随机变量组分别是<script type="math/tex">Y_A</script>，<script type="math/tex">Y_B</script>和<script type="math/tex">Y_C</script>:</p>
<p><img src="image/ch14-2.png" alt="ch14-2"></p>
<p><strong>上述成对的、局部的、全局的马尔科夫性定义是等价的</strong>。</p>
<p><strong>定义14.1(概率无向图模型)</strong> 设有联合概率分布<script type="math/tex">P(Y)</script>，由无向图G=(V,E)表示，在图G中，结点表示随机变量，边表示随机变量之间的依赖关系。如果联合概率分布P(Y)满足成对、局部或全局马尔科夫性，就称此联合概率分布为概率无向图模型，或马尔科夫随机场。</p>
<h3 id="14-1-2-概率无向图模型的因子分解"><a href="#14-1-2-概率无向图模型的因子分解" class="headerlink" title="14.1.2 概率无向图模型的因子分解"></a>14.1.2 概率无向图模型的因子分解</h3><p><strong>定义11.2(团与最大团)</strong> 无向图G中任何两个结点均有边连接的结点子集称为团。若C是无向图G的一个团，并且不能再加进任何一个G的节点使其称为一个更大的团，则称此C为最大团。</p>
<p>如下图所示，图中有2个结点组成的团有5个：(1,2),(2,3),(3,4),(4,2)和(1,3)。有2个最大团：(1,2,3)和(2,3,4)。而(1,2,3,4)不是一个团，因为<script type="math/tex">Y_1</script>和<script type="math/tex">Y_4</script>没有边连接。</p>
<p><img src="image/ch14-3.png" alt="ch14-3"></p>
<p><strong>将概率无向图模型的联合概率分布表示为其最大团上的随机变量的函数的乘积形式的操作，称为概率无向图模型的因子分解</strong>。</p>
<p>给定概率无向图模型，设其无向图为G，C为G上的最大团，<script type="math/tex">Y_C</script>表示C对应的随机变量。那么概率无向图模型的联合概率分布P(Y)可写作图中所有最大团C上的函数<script type="math/tex">\Psi(C)(Y_C)</script>的乘积形式，即</p>
<script type="math/tex; mode=display">
P(Y) = \frac{1}{Z} \prod_C \Psi_C(Y_C) \ (14.5)</script><p>其中，Z是规范化因子，由式</p>
<script type="math/tex; mode=display">
Z = \sum_Y \prod_C \Psi_C(Y_C) \ (14.6)</script><p>给出。</p>
<p>规范化因子保证P(Y)构成一个概率分布。函数<script type="math/tex">\Psi_C(Y_C)</script>称为势函数(势函数是严格正的)，通常定义为指数函数:</p>
<script type="math/tex; mode=display">
\Psi_C(Y_C) = \exp \{-E(Y_C)\} \ (14.7)</script><p>概率无向图模型的因子分解由下述定理来保证。</p>
<p><strong>定理14.1(Hammersley-Clifford定理)</strong> 概率无向图模型的联合概率分布P(Y)可以表示为如下形式：</p>
<script type="math/tex; mode=display">
P(Y) = \frac{1}{Z} \prod_C \Psi_C(Y_C)</script><script type="math/tex; mode=display">
Z = \sum_Y \prod_C \Psi_C(Y_C)</script><p>其中，C是无向图的最大团，<script type="math/tex">Y_C</script>是C的结点对应的随机变量，<script type="math/tex">\Psi_C(Y_C)</script>是C上定义的严格整函数，乘积是在无向图所有的最大团上进行的。</p>
<h2 id="14-2-条件随机场的定义与形式"><a href="#14-2-条件随机场的定义与形式" class="headerlink" title="14.2 条件随机场的定义与形式"></a>14.2 条件随机场的定义与形式</h2><h3 id="14-2-1-条件随机场的定义"><a href="#14-2-1-条件随机场的定义" class="headerlink" title="14.2.1 条件随机场的定义"></a>14.2.1 条件随机场的定义</h3><p>条件随机场是给定随机变量X条件下，随机变量Y的马尔科夫随机场。</p>
<p>线性链条件随机场的条件概率模型P(Y|X)中，Y是输出变量，表示标记序列，X是输入变量，表示需要标注的观测序列。也把标记序列称为状态序列。</p>
<p>学习时，利用训练数据集通过极大似然估计或正则化的极大似然估计得到条件概率模型<script type="math/tex">\hat{P}(Y|X)</script>;</p>
<p>预测时，对于给定的输入序列x，求出条件概率<script type="math/tex">\hat{P}(y|x)</script>最大的输出序列<script type="math/tex">\hat{y}</script>。</p>
<p><strong>定理14.3(条件随机场)</strong> 设X与Y是随机变量，P(Y|X)是在给定X的条件下，Y的条件概率分布。若随机变量Y构成一个由无向图G=(V,E)表示的马尔科夫随机场，即</p>
<script type="math/tex; mode=display">
P(Y_v|X,Y_w,w\ne v) = P(Y_v|X,Y_w,w \sim v) \ (14.8)</script><p>对任意结点v成立，则称条件概率分布P(Y|X)为条件随机场。式中w~v表示在图G=(V,E)中与结点v有边连接的所有结点w；<script type="math/tex">w \ne v</script>表示结点v以外的所有结点，<script type="math/tex">Y_v,Y_u,Y_w</script>为结点v，u与w对应的随机变量。</p>
<blockquote>
<p>在定义中并没有要求X和Y具有相同的结构。<strong>现实中，一般假设X与Y具有相同的图结构</strong>。</p>
</blockquote>
<p><strong>定义11.4(线性链条件随机场)</strong> 设<script type="math/tex">X=(X_1,X_2,\cdots,X_n)</script>，<script type="math/tex">Y=(Y_1,Y_2,\cdots,Y_n)</script>均为线性链表示的随机变量序列，若在给定随机变量序列X的条件下，随机变量序列Y的条件概率分布P(Y|X)构成条件随机场，即满足马尔科夫性:</p>
<script type="math/tex; mode=display">
P(Y_i|X,Y_1,\cdots,Y_{i-1},Y_{i+1},\cdots,Y_n) = P(Y_i|X,Y_{i-1},Y_{i+1}) \ , i=1,2,\cdots,n \ (14.9)</script><p><strong>注意：</strong>在i=1或n时只考虑单边</p>
<p>则称P(Y|X)为线性链条件随机场。在标注问题中，X表示输入观测序列，Y表示对应的输出标记序列或状态序列。</p>
<h3 id="14-2-2-条件随机场的参数化形式"><a href="#14-2-2-条件随机场的参数化形式" class="headerlink" title="14.2.2 条件随机场的参数化形式"></a>14.2.2 条件随机场的参数化形式</h3><p><strong>定理14.2(线性链条件随机场的参数化形式)</strong> 设P(Y|X)为线性链条件随机场，则在随机变量X取值为x的条件下，随机变量Y取值为y的条件概率具有如下形式:</p>
<script type="math/tex; mode=display">
P(y|x) = \frac{1}{Z(x)} \exp \left(\sum_{i,k} \lambda_k t_k(y_{i-1},y_i,x,i)+\sum_{i,l} \mu_l s_l(y_i,x,i) \right) \ (14.10)</script><p>其中，</p>
<script type="math/tex; mode=display">
Z(x) = \sum_y \exp \left( \sum_{i,k}\lambda_k t_k(y_{i-1},y_i,x,i)+\sum_{i,l} \mu_l s_l(y_i,x,i) \right) \ (14.11)</script><p>式中，<script type="math/tex">t_k</script>和<script type="math/tex">s_l</script>是特征函数，<script type="math/tex">\lambda_k</script>和<script type="math/tex">\mu_l</script>是对应的权值。<script type="math/tex">Z(x)</script>是规范化因子，求和是在所有可能的输出序列上进行的。</p>
<p>式(14.10)和式(14.11)是线性链条件随机场模型的基本形式，表示给定输入序列x，对输出序列y预测的条件概率。</p>
<p>对于<strong><script type="math/tex">t_k</script>是定义在边上的特征函数，称为转移特征，依赖于当前和前一个位置</strong>；</p>
<p>对于<strong><script type="math/tex">s_l</script>是定义在结点上的特征函数，称为状态特征，依赖于当前位置</strong>。</p>
<p>对于<script type="math/tex">t_k</script>和<script type="math/tex">s_l</script>都依赖于位置，是局部特征函数。</p>
<p>通常，特征函数<script type="math/tex">t_k</script>和<script type="math/tex">s_l</script>取值为1或0；当满足特征条件时取值为1，否则为0.条件随机场完全由特征函数<script type="math/tex">t_k</script>，<script type="math/tex">s_l</script>和对应的权值<script type="math/tex">\lambda_k</script>，<script type="math/tex">\mu_l</script>确定。</p>
<p><strong>线性链条件随机场为对数线性模型</strong>。</p>
<h3 id="14-2-3-条件随机场的简化形式"><a href="#14-2-3-条件随机场的简化形式" class="headerlink" title="14.2.3 条件随机场的简化形式"></a>14.2.3 条件随机场的简化形式</h3><p>条件随机场的简化思路：对同一个特征在各个位置求和，将局部特征函数转化为一个全局特征函数，这样就可以将条件随机场写成权值向量和特征向量的内积形式，即条件随机场的简化形式。</p>
<p>首先将转移特征和状态特征及其权值用统一的符号表示。设有<script type="math/tex">K_1</script>个转移特征，<script type="math/tex">K_2</script>个状态特征，<script type="math/tex">K=K_1+K_2</script>，记：</p>
<script type="math/tex; mode=display">
f_k(y_{i-1},y_i,x,i) = \left\{\begin{aligned}&t_k(y_{i-1},y_i,x,i),k=1,2,\cdots,K_1\\ &s_l(y_i,x,i),k=K_1+l;l=1,2,\cdots,K_2\end{aligned}\right . \ (14.12)</script><p>然后，对转移与状态特征在各个位置i求和，记作：</p>
<script type="math/tex; mode=display">
f_k(y,x) = \sum_{i=1}^n f_k(y_{i-1},y_i,x,i),k=1,2,\cdots,K \ (14.13)</script><p>用<script type="math/tex">w_k</script>表示特征<script type="math/tex">f_k(y,x)</script>的权值，即</p>
<script type="math/tex; mode=display">
w_k = \left\{ \begin{aligned}&\lambda_k, k=1,2,\cdots,K_1 \\ &\mu_l,k=K_1+l;l=1,2,\cdots,K_2\end{aligned}\right . \ (14.14)</script><p>于是，条件随机场(14.11)~(14.12)可表示为：</p>
<script type="math/tex; mode=display">
P(y|x) = \frac{1}{Z(x)} \exp \sum_{k=1}^K w_k f_k(y,x) \ (14.15)</script><script type="math/tex; mode=display">
Z(x) = \sum_y \exp \sum_{k=1}^K w_k f_k(y,x) \ (14.16)</script><p>若以w表示权值向量，即</p>
<script type="math/tex; mode=display">
w = (w_1,w_2,\cdots,w_K)^{\top} \ (14.17)</script><p>以<script type="math/tex">F(y,x)</script>表示全局特征向量，即</p>
<script type="math/tex; mode=display">
F(y,x) = (f_1(y,x),f_2(y,x),\cdots,f_K(y,x))^{\top} \ (14.18)</script><p>则条件随机场可以写成向量w与F(y,x)的内积形式：</p>
<script type="math/tex; mode=display">
P_w(y|x) = \frac{\exp(w.F(y,x))}{Z_w(x)} \ (14.19)</script><p>其中，</p>
<script type="math/tex; mode=display">
Z_w(x) = \sum_y \exp (w.F(y,x)) \ (14.20)</script><h3 id="14-2-4-条件随机场的矩阵形式"><a href="#14-2-4-条件随机场的矩阵形式" class="headerlink" title="14.2.4 条件随机场的矩阵形式"></a>14.2.4 条件随机场的矩阵形式</h3><p>假设<script type="math/tex">P_w(y|x)</script>由式(14.15)~(14.16)给出的线性链条件随机场，表示对给定观测序列x，相应的标记序列y的条件概率。引进特殊的起点和终点状态标记<script type="math/tex">y_0=\mathrm{start},y_{n+1}=\mathrm{stop}</script>，这时<script type="math/tex">P_w(y|x)</script>可以通过矩阵形式表示。</p>
<p>对观测序列x的每一个位置i=1,2,…,n+1，定义一个m阶矩阵(m是标记<script type="math/tex">y_i</script>取值的个数)</p>
<script type="math/tex; mode=display">
M_i(x) = [M_i(y_{i-1},y_i|x)] \ (14.21)</script><script type="math/tex; mode=display">
M_i(y_{i-1},y_i|x) = \exp (W_i(y_{i-1},y_i|x)) \ (14.22)</script><script type="math/tex; mode=display">
W_i(y_{i-1},y_i|x) = \sum_{k=1}^K w_k f_k(y_{i-1},y_i,x,i) \ (14.23)</script><p>给定观测序列x，相应标记序列y的非规范化概率可以通过该序列n+1个矩阵适当元素的乘积<script type="math/tex">\prod_{i=1}^{n+1}M_i(y_{i-1},y_i|x)</script>表示。于是，条件概率<script type="math/tex">P_w(y|x)</script>是：</p>
<script type="math/tex; mode=display">
P_w(y|x) = \frac{1}{Z_w(x)} \prod_{i=1}^{n+1}M_i(y_{i-1},y_i|x) \ (14.24)</script><p>其中，<script type="math/tex">Z_w(x)</script>为规范化因子，是n+1个矩阵的乘积的(start,stop)元素：</p>
<script type="math/tex; mode=display">
Z_w(x) = (M_1(x)M_2(x)\cdots M_{n+1}(x))_{\mathrm{start,stop}} \ (14.25)</script><p>注意，<script type="math/tex">y_0</script>=start与<script type="math/tex">y_{n+1}</script>=stop表示开始状态与终止状态，规范化因子<script type="math/tex">Z_w(x)</script>是以start为起点stop为终点通过状态的所有路径<script type="math/tex">y_1y_2\cdots y_n</script>的非规范化概率<script type="math/tex">\prod^{n+1}_{i=1} M_i(y_{i-1},y_i|x)</script>之和。</p>
<h2 id="14-3-条件随机场的概率计算问题"><a href="#14-3-条件随机场的概率计算问题" class="headerlink" title="14.3 条件随机场的概率计算问题"></a>14.3 条件随机场的概率计算问题</h2><p>条件随机场的概率计算问题是给定条件随机场P(Y|X)，输入序列x和输出序列y，计算条件概率<script type="math/tex">P(Y_i=y_i|x)</script>，<script type="math/tex">P(Y_{i-1}=y_{i-1},Y_i=y_i|x)</script>以及相应的数学期望的问题。</p>
<h3 id="14-3-1-前向-后向算法"><a href="#14-3-1-前向-后向算法" class="headerlink" title="14.3.1 前向-后向算法"></a>14.3.1 前向-后向算法</h3><p>对每个指标i=0,1,…,n+1，定义前向向量<script type="math/tex">\alpha_i(x)</script>:</p>
<script type="math/tex; mode=display">
\alpha_0(y|x) = \left\{\begin{aligned}&1,y=\mathrm{start}\\&0,\mathrm{others}\end{aligned}\right . \ (14.26)</script><p>递推公式为</p>
<script type="math/tex; mode=display">
\alpha_i^{\top}(y_i|x) = \alpha_{i-1}^{\top}(y_{i-1}|x)[M_i(y_{i-1},y_i|x)]\ ,i=1,2,\cdots,n+1 \ (14.27)</script><p>又可表示为</p>
<script type="math/tex; mode=display">
\alpha_i^{\top}(x) = \alpha_{i-1}^{\top}(x)M_i(x) \ (14.28)</script><p>关于<script type="math/tex">\alpha_i(y_i|x)</script>表示在位置i的标记是<script type="math/tex">y_i</script>并且到位置i的前部分标记序列的非规范化概率，<script type="math/tex">y_i</script>可取的值有m个，所以<script type="math/tex">\alpha_i(x)</script>是m维列向量。</p>
<p>同样，对每个指标i=0,1,…,n+1，定义后向向量<script type="math/tex">\beta_i(x)</script>：</p>
<script type="math/tex; mode=display">
\beta_{n+1}(y_{n+1}|x) = \left\{\begin{aligned}&1,y_{n+1}=\mathrm{stop}\\&0,\mathrm{others}\end{aligned}\right. \ (14.29)</script><script type="math/tex; mode=display">
\beta_i(y_i|x) = [M_i(y_i,y_{i+1}|x)]\beta_{i+1}(y_{i+1}|x) \ (14.30)</script><p>又可表示为</p>
<script type="math/tex; mode=display">
\beta_i(x) = M_{i+1}(x) \beta_{i+1}(x) \ (14.31)</script><p>关于<script type="math/tex">\beta_i(y_i|x)</script>表示在位置i的标记为<script type="math/tex">y_i</script>并且从i+1到n的后部分标记序列的非规范化概率。</p>
<p>由前向-后向向量定义不难得到：</p>
<script type="math/tex; mode=display">
Z(x) = \alpha_n^{\top}(x) \bullet 1=1^{\top} \bullet \beta_1(x)</script><p>这里，1是元素均为1的m维列向量。</p>
<h3 id="14-3-2-概率计算"><a href="#14-3-2-概率计算" class="headerlink" title="14.3.2 概率计算"></a>14.3.2 概率计算</h3><p>按照前向-后向向量的定义，很容易计算标记序列在位置i是标记<script type="math/tex">y_i</script>的条件概率和在位置i-1与i是标记<script type="math/tex">y_{i-1}</script>和<script type="math/tex">y_i</script>的条件概率：</p>
<script type="math/tex; mode=display">
P(Y_i=y_i|x) = \frac{\alpha_i^{\top}(y_i|x)\beta_i(y_i|x)}{Z(x)} \ (14.32)</script><script type="math/tex; mode=display">
P(Y_{i-1}=y_{i-1},Y_i=y_i|x) = \frac{\alpha_{i-1}^{\top}(y_{i-1}|x)M_i(y_{i-1},y_i|x)\beta_i(y_i|x)}{Z(x)} \ (14.33)</script><p>其中，</p>
<script type="math/tex; mode=display">
Z(x) = \alpha_n^{\top}(x)\bullet 1</script><h3 id="14-3-3-期望值的计算"><a href="#14-3-3-期望值的计算" class="headerlink" title="14.3.3 期望值的计算"></a>14.3.3 期望值的计算</h3><p>利用前向-后向向量，可以计算特征函数关于联合分布P(X,Y)和条件分布P(Y|X)的数学期望。</p>
<p>特征函数<script type="math/tex">f_k</script>关于条件分布P(Y|X)的数学期望是：</p>
<script type="math/tex; mode=display">
\begin{aligned} E_{P(Y|X)}[f_k] &= \sum_y P(y|x)f_k(y,x) \\ &=\sum_{i=1}^{n+1}\sum_{y_{i-1}y_i} f_k(y_{i-1},y_i,x,i)\frac{\alpha_{i-1}^{\top}(y_{i-1}|x)M_i(y_{i-1},y_i|x)\beta_i(y_i|x)}{Z(x)}\end{aligned} \ k=1,2,\cdots,K \ (14.34)</script><p>其中，</p>
<script type="math/tex; mode=display">
Z(x) = \alpha_n^{\top}(x)\bullet 1</script><p>假设经验分布为<script type="math/tex">\tilde{P}(X)</script>，特征函数<script type="math/tex">f_k</script>关于联合分布P(X,Y)的数学期望是：</p>
<script type="math/tex; mode=display">
\begin{aligned}E_{P(X,Y)}[f_k] &= \sum_{x,y}P(x,y)\sum_{i=1}^{n+1}f_k(y_{i-1},y_i,x,i)\\&= \sum_x \tilde{P}(x)\sum_y P(y|x) \sum_{i=1}^{n+1} f_k(y_{i-1},y_i,x,i)\\&=\sum_x \tilde{P}(x) \sum_{i=1}^{n+1}\sum_{y_{i-1}y_i}f_k(y_{i-1},y_i,x,i)\frac{\alpha_{i-1}^{\top}(y_{i-1}|x)M_i(y_{i-1},y_i|x)\beta_i(y_i|x)}{Z(x)} \end{aligned} \ k=1,2,\cdots,K \ (14.35)</script><p>其中，</p>
<script type="math/tex; mode=display">
Z(x) = \alpha_n^{\top}(x).1</script><p>式(14.34)和式(14.35)是特征函数数学期望的一般计算公式。</p>
<p>对于转移特征<script type="math/tex">t_k(y_{i-1},y_i,x,i)</script>，k=1,2,…,<script type="math/tex">K_1</script>，可以将式中的<script type="math/tex">f_k</script>换成<script type="math/tex">t_k</script>；</p>
<p>对于状态特征，可以将式中的<script type="math/tex">f_k</script>换成<script type="math/tex">s_i</script>，表示为<script type="math/tex">s_l(y_i,x,i)</script>，<script type="math/tex">k=K_1+l,l=1,2,\cdots,K_2</script>。</p>
<p>根据式(14.31)~(14.35)，对于给定的观测序列x与标记序列y，可以通过一次前向扫描计算<script type="math/tex">\alpha_i</script>及Z(x)，通过一次后向扫描计算<script type="math/tex">\beta_i</script>,从而计算所有的概率和特征的期望。</p>
<h2 id="14-4-条件随机场的学习算法"><a href="#14-4-条件随机场的学习算法" class="headerlink" title="14.4 条件随机场的学习算法"></a>14.4 条件随机场的学习算法</h2><h3 id="14-4-1-改进的迭代尺度法"><a href="#14-4-1-改进的迭代尺度法" class="headerlink" title="14.4.1 改进的迭代尺度法"></a>14.4.1 改进的迭代尺度法</h3><p>已知训练数据集，由此可知经验概率分布<script type="math/tex">\tilde{P}(X,Y)</script>。可以通过极大化训练数据的对数似然函数来求模型参数。</p>
<script type="math/tex; mode=display">
L(w) = L_{\tilde{P}}(P_w) = \log \prod_{x,y}P_w(y|x)^{\tilde{P}(x,y)}=\sum_{x,y}\tilde{P}(x,y)\log P_w(y|x)</script><p>当<script type="math/tex">P_w</script>是一个由式(14.15)和式(14.16)给出的条件随机场模型时，对数似然函数为</p>
<script type="math/tex; mode=display">
\begin{aligned}L(w)&=\sum_{x,y}\tilde{P}(x,y)\log P_w(y|x)\\ &= \sum_{x,y} \left[\tilde{P}(x,y)\sum_{k=1}^K w_k f_k(y,x)-\tilde{P}(x,y)\log Z_w(x)\right]\\&=\sum_{j=1}^N\sum_{k=1}^K w_k f_k(y_j,x_j)-\sum_{j=1}^N \log Z_w(x_j)\end{aligned}</script><p>改进的迭代尺度法通过迭代的方法不断优化对数似然函数改变量的下界，达到极大化对数似然函数的目的。</p>
<p>假设模型的当前参数向量为<script type="math/tex">w=(w_1,w_2,\cdots,w_K)^{\top}</script>，向量的增量为<script type="math/tex">\delta=(\delta_1,\delta_2,\cdots,\delta_K)^{\top}</script>，更新参数向量为<script type="math/tex">w+\delta=(w_1+\delta_1,w_2+\delta_2,\cdots,w_K+\delta_K)^{\top}</script>。在每步迭代过程中，改进的迭代尺度法通过依次求解式(14.36)和式(14.37)，得到<script type="math/tex">\delta=(\delta_1,\delta_2,\cdots,\delta_K)^{\top}</script>。(更多推导细节可参考6.3.1节)</p>
<p>关于转移特征<script type="math/tex">t_k</script>的更新方程为</p>
<script type="math/tex; mode=display">
\begin{aligned}E_{\tilde{P}}[t_k] &= \sum_{x,y} \tilde{P}(x,y)\sum_{i=1}^{n+1}t_k(y_{i-1},y_i,x,i) \\ &=\sum_{x,y}\tilde{P}(x)P(y|x)\sum_{i=1}^{n+1}t_k(y_{i-1},y_i,x,i)\exp(\delta_k T(x,y)) \end{aligned} \ k=1,2,\cdots,K_1 \ (14.36)</script><p>关于状态特征<script type="math/tex">s_l</script>的更新方程为:</p>
<script type="math/tex; mode=display">
\begin{aligned}E_{\tilde{P}}[s_l] &= \sum_{x,y}\tilde{P}(x,y)\sum_{i=1}^{n+1}s_l(y_i,x,i)\\ &= \sum_{x,y}\tilde{P}(x)P(y|x)\sum_{i=1}^n s_l(y_i,x,i)\exp(\delta_{K_1+l}T(x,y)) \end{aligned} \ l=1,2,\cdots,K_2 \ (14.37)</script><p>这里，T(x,y)是在数据(x,y)中出现所有特征数的总和:</p>
<script type="math/tex; mode=display">
T(x,y) = \sum_k f_k(y,x) = \sum_{k=1}^K \sum_{i=1}^{n+1} f_k(y_{i-1},y_i,x,i) \ (14.38)</script><p><strong>算法14.1(条件随机场模型学习的改进的迭代尺度法)</strong></p>
<p>输入：特征函数<script type="math/tex">t_1,t_2,\cdots,t_{K_1}</script>,<script type="math/tex">s_1,s_2,\cdots,s_{K_2}</script>；经验分布<script type="math/tex">\tilde{P}(x,y)</script></p>
<p>输出：参数估计值<script type="math/tex">\hat{w}</script>；模型<script type="math/tex">P_{\hat{w}}</script>。</p>
<p>(1)对所有<script type="math/tex">k \in \{1,2,\cdots,K\}</script>，取初值<script type="math/tex">w_k=0</script></p>
<p>(2)对每一<script type="math/tex">k\in \{1,2,\cdots,K\}</script>:</p>
<p>​    (a)当k=1,2,…,<script type="math/tex">K_1</script>时，令<script type="math/tex">\delta_k</script>是方程</p>
<script type="math/tex; mode=display">
\sum_{x,y} \tilde{P}(x)P(y|x)\sum_{i=1}^{n+1} t_k(y_{i-1},y_i,x,i)\exp(\delta_kT(x,y))=E_{\tilde{P}}[t_k]</script><p>​    的解。</p>
<p>​    当k=<script type="math/tex">K_1+l</script>，<script type="math/tex">l</script>=1,2,…,<script type="math/tex">K_2</script>时，令<script type="math/tex">\delta_{K_1+l}</script>是方程</p>
<script type="math/tex; mode=display">
\sum_{x,y} \tilde{P}(x)P(y|x)\sum_{i=1}^n s_l(y_i,x,i)\exp(\delta_{K_1+l}T(x,y))=E_{\tilde{P}}[s_l]</script><p>​    的解，式中<script type="math/tex">T(x,y)</script>由式(14.38)给出。</p>
<p>​    (b)更新<script type="math/tex">w_k</script>的值:<script type="math/tex">w_k \leftarrow w_k+\delta_k</script></p>
<p>(3)如果不是所有<script type="math/tex">w_k</script>都收敛，重复步骤(2)。</p>
<p>在式(14.36)和式(14.37)中，T(x,y)表示数据(x,y)中的特征总数，对不同的数据(x,y)取值可能不同。为了处理这个问题，定义松弛特征:</p>
<script type="math/tex; mode=display">
s(x,y) = S-\sum_{i=1}^{n+1}\sum_{k=1}^K f_k(y_{i-1},y_i,x,i) \ (14.39)</script><p>式中S是一个常数。选择足够大的常数S使得对训练数据集的所有数据(x,y)，<script type="math/tex">s(x,y)\ge 0</script>成立。这时特征总数可取S。</p>
<p>由式(14.36)，对于转移特征<script type="math/tex">t_k</script>，<script type="math/tex">\delta_k</script>的更新方程是：</p>
<script type="math/tex; mode=display">
\sum_{x,y} \tilde{P}(x)P(y|x)\sum_{i=1}^{n+1}t_k (y_{i-1},y_i,x,i)\exp(\delta_k S) = E_{\tilde{P}}[t_k] \ (14.40)</script><script type="math/tex; mode=display">
\delta_k = \frac{1}{S} \log \frac{E_{\tilde{P}}[t_k]}{E_P[t_k]} \ (14.41)</script><p>其中，</p>
<script type="math/tex; mode=display">
E_P(t_k) = \sum_x \tilde{P}(x) \sum_{i=1}^{n+1}\sum_{y_{i-1},y_i} t_k (y_{i-1},y_i,x,i)\frac{\alpha_{i-1}^{\top}(y_{i-1}|x)M_i(y_{i-1},y_i|x)\beta_i(y_i|x)}{Z(x)} \ (14.42)</script><p>同样由式(14.37)，对于状态特征<script type="math/tex">s_l</script>，<script type="math/tex">\delta_k</script>的更新方程是</p>
<script type="math/tex; mode=display">
\sum_{x,y} \tilde{P}(x) P(y|x) \sum_{i=1}^n s_l(y_i,x,i)\exp (\delta_{K_1+l}S)=E_{\tilde{p}}[s_l] \ (14.43)</script><script type="math/tex; mode=display">
\delta_{K_1+1}=\frac{1}{S}\log \frac{E_{\tilde{P}}[s_l]}{E_P[s_l]} \ (14.44)</script><p>其中，</p>
<script type="math/tex; mode=display">
E_P(s_l) = \sum_x \tilde{P}(x)\sum_{i=1}^n \sum_{y_i} s_l(y_i,x,i)\frac{\alpha_i^{\top}(y_i|x)\beta_i(y_i|x)}{Z(x)} \ (14.45)</script><p>以上算法称为算法S。</p>
<p>在算法S中需要使常数S取足够大，这样一来，每步迭代的增量向量会变大，算法收敛会变慢。算法T试图解决这个问题。算法T对每个观测序列x计算其特征总数最大值T(x):</p>
<script type="math/tex; mode=display">
T(x) = \max_y T(x,y) \ (14.46)</script><p>利用前向-后向递推公式，可以很容易地计算T(x)=t.</p>
<p>关于<strong>转移特征参数的更新方程</strong>可以写成:</p>
<script type="math/tex; mode=display">
\begin{aligned}E_{\tilde{P}}[t_k] &= \sum_{x,y}\tilde{P}(x)P(y|x)\sum_{i=1}^{n+1}t_k(y_{i-1},y_i,x,i)\exp(\delta_k T(x))\\&=\sum_x \tilde{P}(x)\sum_y P(y|x)\sum_{i=1}^{n+1}t_k(y_{i-1},y_i,x,i)\exp(\delta_k T(x))\\&=\sum_x \tilde{P}(x)a_{k,t} \exp(\delta_k.t) \\&= \sum_{t=0}^{T_{\mathrm{max}}}a_{k,t}\beta_k^t \end{aligned} \ (14.47)</script><p>这里，<script type="math/tex">a_{k,t}</script>是特征<script type="math/tex">t_k</script>的期望值，<script type="math/tex">\delta_k=\log \beta_k</script>。<script type="math/tex">\beta_k</script>是多项式方程(14.47)唯一的实根，可以用牛顿法求得。从而求得相关的<script type="math/tex">\delta_k</script>。</p>
<p>关于<strong>状态特征的参数更新方程</strong>可以写成：</p>
<script type="math/tex; mode=display">
\begin{aligned}E_{\tilde{P}}[s_l]&=\sum_{x,y}\tilde{P}(x)P(y|x)\sum_{i=1}^n s_l(y_i,x,i)\exp(\delta_{K_1+1}T(x))\\&=\sum_x \tilde{P}(x)\sum_y P(y|x)\sum_{i=1}^n s_l(y_i,x,i)\exp (\delta_{K_1+1}T(x))\\&=\sum_x \tilde{P}(x)b_{l,t}\exp(\delta_k.t)\\&=\sum_{t=0}^{T_{\mathrm{max}}}b_{l,t}\gamma_l^t \end{aligned} \ (14.48)</script><p>这里，<script type="math/tex">b_{l,t}</script>是特征<script type="math/tex">s_l</script>的期望值，<script type="math/tex">\delta_l=\log \gamma_l</script>，<script type="math/tex">\gamma_l</script>是多项式方程(14.48)唯一的实根，也可以用牛顿法求得。</p>
<h3 id="14-4-2-拟牛顿法"><a href="#14-4-2-拟牛顿法" class="headerlink" title="14.4.2 拟牛顿法"></a>14.4.2 拟牛顿法</h3><p>条件随机场模型学习还可以应用牛顿法或拟牛顿法(参考第15章)。对于条件随机场模型：</p>
<script type="math/tex; mode=display">
P_w(y|x)=\frac{\exp \left(\sum_{i=1}^n w_i f_i(x,y)\right)}{\sum_y \exp \left(\sum_{i=1}^n w_i f_i(x,y)\right)} \ (14.49)</script><p>学习的优化目标函数是：</p>
<script type="math/tex; mode=display">
\min_{w \in R^n} f(w) = \sum_x \tilde{P}(x) \log \sum_y \exp \left(\sum_{i=1}^n w_i f_i(x,y)\right)-\sum_{x,y}\tilde{P}(x,y)\sum_{i=1}^n w_i f_i(x,y) \ (14.50)</script><p>其梯度函数是</p>
<script type="math/tex; mode=display">
g(w) = \sum_{x,y} \tilde{P}(x)P_w(y|x)f(x,y)-E_{\tilde{P}}(f) \ (14.51)</script><p>拟牛顿法的BFGS算法如下。</p>
<p><strong>算法14.2(条件随机场模型学习的BFGS算法)</strong></p>
<p>输入：特征函数<script type="math/tex">f_1,f_2,\cdots,f_n</script>；经验分布<script type="math/tex">\tilde{P}(X,Y)</script>；</p>
<p>输出：最优参数值<script type="math/tex">\hat{w}</script>；最优模型<script type="math/tex">P_{\hat{w}}(y|x)</script></p>
<p>(1)选定初始点<script type="math/tex">w^{(0)}</script>，取<script type="math/tex">B_0</script>为正定对称矩阵，置k=0</p>
<p>(2)计算<script type="math/tex">g_k=g(w^{(k)})</script>。若<script type="math/tex">g_k=0</script>，则停止计算；否则转(3)</p>
<p>(3)由<script type="math/tex">B_kp_k = -g_k</script>求出<script type="math/tex">p_k</script></p>
<p>(4)一维搜索：求<script type="math/tex">\lambda_k</script>使得</p>
<script type="math/tex; mode=display">
f(w^{(k)}+\lambda_kp_k) = \min_{\lambda \ge 0} f(w^{(k)}+\lambda p_k)</script><p>(5)置<script type="math/tex">w^{(k+1)}=w^{(k)}+\lambda_k p_k</script></p>
<p>(6)计算<script type="math/tex">g_{k+1}=g(w^{(k+1)})</script>，若<script type="math/tex">g_{k+1}=0</script>，则停止计算；否则，按下式求出<script type="math/tex">B_{k+1}</script>：</p>
<script type="math/tex; mode=display">
B_{k+1} = B_k+\frac{y_k y_k^{\top}}{y_k^{\top}\delta_k}-\frac{B_k\delta_k \delta_k^{\top}B_k}{\delta_k^{\top}B_k\delta_k}</script><p>其中，</p>
<script type="math/tex; mode=display">
y_k = g_{k+1}-g_k,\delta_k = w^{(k+1)}-w^{(k)}</script><p>(7)置k=k+1，转(3)</p>
<h2 id="14-5-条件随机场的预测算法"><a href="#14-5-条件随机场的预测算法" class="headerlink" title="14.5 条件随机场的预测算法"></a>14.5 条件随机场的预测算法</h2><p>条件随机场的预测问题是给定条件随机场P(Y|X)和输入序列(观测序列)x，求条件概率最大的输出序列(标记序列)<script type="math/tex">y^*</script>，即对观测序列进行标注。</p>
<blockquote>
<p>条件随机场的预测算法是维特比算法（请参考13.4节）</p>
</blockquote>
<p>由式(14.19)可得:</p>
<script type="math/tex; mode=display">
\begin{aligned}y^* &= \arg \max_y P_w(y|x) \\ &= \arg \max_y \frac{\exp(w.F(y,x))}{Z_w(x)} \\ &=\arg \max_y \exp(w.F(y,x))\\ &=\arg \max_y(w.F(y,x))\end{aligned}</script><p>于是，条件随机场的预测问题成为求非规范化概率最大的最优路径问题：</p>
<script type="math/tex; mode=display">
\max_y (w.F(y,x)) \ (14.52)</script><p>这里，路径表示标记序列。其中，</p>
<script type="math/tex; mode=display">
w = (w_1,w_2,\cdots,w_K)^{\top}</script><script type="math/tex; mode=display">
F(y,x) = (f_1(y,x),f_2(y,x),\cdots,f_K(y,x))^{\top}</script><script type="math/tex; mode=display">
f_k(y,x) = \sum_{i=1}^n f_k(y_{i-1},y_i,x,i), k=1,2,\cdots,K</script><p>注意，这时只需计算非规范化概率，而不必计算概率，可以大大提高效率。</p>
<p>为了求解最优路径，将式(14.52)写成如下形式：</p>
<script type="math/tex; mode=display">
\max_y \sum_{i=1}^n w.F_i(y_{i-1},y_i,x) \ (14.53)</script><p>其中，</p>
<script type="math/tex; mode=display">
F_i(y_{i-1},y_i,x)=(f_1(y_{i-1},y_i,x,i),f_2(y_{i-1},y_i,x,i),\cdots,f_K(y_{i-1},y_i,x,i))^{\top}</script><p>是局部特征向量。</p>
<p><strong>以下为维特比算法的说明：</strong></p>
<p>首先求出位置1的各个标记j=1,2,…,m的非规范化概率:</p>
<script type="math/tex; mode=display">
\delta_1(j) = w.F_1(y_0=\mathrm{start},y_1=j,x),j=1,2,\cdots,m \ (14.54)</script><p>一般地，由地推公式，求出到位置i的各个标记<script type="math/tex">l=1,2,\cdots,m</script>的非规范化概率的最大值，同时记录非规范化概率最大值的路径：</p>
<script type="math/tex; mode=display">
\delta_i(l) = \max_{1\le j \le m}\{\delta_{i-1}(j)+w.F_i(y_{i-1}=j,y_i=l,x)\},l=1,2,\cdots,m \ (14.55)</script><script type="math/tex; mode=display">
\Psi_i(l) = \arg \max_{1\le j \le m}\{\delta_{i-1}(j)+w.F_i(y_{i-1}=j,y_i=l,x)\},l=1,2,\cdots,m \ (14.56)</script><p>直到i=n时终止。这时求得非规范化概率的最大值为:</p>
<script type="math/tex; mode=display">
\max_y(w.F(y,x))=\max_{1\le j\le m} \delta_n(j) \ (14.57)</script><p>及最优路径的终点</p>
<script type="math/tex; mode=display">
y^*_n = \arg \max_{1\le j \le m}\delta_n(j) \ (14.58)</script><p>由此最优路径终点返回，</p>
<script type="math/tex; mode=display">
y^*_i = \Psi_{i+1}(y^*_{i+1}) , i=n-1,n-2,\cdots,1 \ (14.59)</script><p>求得最优路径<script type="math/tex">y^* = (y_1^*,y_2^*,\cdots,y_n^*)^{\top}</script>。</p>
<p>综上所述，得到条件随机场预测的维特比算法。</p>
<p><strong>算法14.3(条件随机场预测的维特比算法)</strong></p>
<p>输入:模型特征向量F(y,x)和权值向量w，观测序列<script type="math/tex">x=(x_1,x_2,\cdots,x_n)</script>；</p>
<p>输出:最优路径<script type="math/tex">y^*=(y_1^*,y_2^*,\cdots,y_n^*)</script></p>
<p>(1)初始化</p>
<script type="math/tex; mode=display">
\delta_1(j)=w.F_1(y_0=\mathrm{start},y_1=j,x),j=1,2,\cdots,m</script><p>(2)递推。对i=2,3,…,n</p>
<script type="math/tex; mode=display">
\delta_i(l)=\max_{1\le j \le m}\{\delta_{i-1}(j)+w.F_i(y_{i-1}=j,y_i=l,x)\},l=1,2,\cdots,m</script><script type="math/tex; mode=display">
\Psi_i(l)=\arg\max_{1\le j \le m}\{\delta_{i-1}(j)+w.F_i(y_{i-1}=j,y_i=l,x)\} , l=1,2,\cdots,m</script><p>(3)终止</p>
<script type="math/tex; mode=display">
\max_y(w.F(y,x))=\max_{1\le j \le m} \delta_n(j)</script><script type="math/tex; mode=display">
y^*_n = \arg \max_{1\le j \le m}\delta_n(j)</script><p>(4)返回路径</p>
<script type="math/tex; mode=display">
y_i^* = \Psi_{i+1}(y^*_{i+1}),i=n-1,n-2,\cdots,1</script><p>求得最优路径<script type="math/tex">y^*=(y^*_1,y_2^*,\cdots,y_n^*)</script></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/判别模型/" rel="tag"># 判别模型</a>
          
            <a href="/tags/标注模型/" rel="tag"># 标注模型</a>
          
            <a href="/tags/条件随机场/" rel="tag"># 条件随机场</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/06/14/隐马尔科夫模型/" rel="next" title="隐马尔科夫模型">
                <i class="fa fa-chevron-left"></i> 隐马尔科夫模型
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/06/14/牛顿法和拟牛顿法/" rel="prev" title="牛顿法和拟牛顿法">
                牛顿法和拟牛顿法 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">jozee</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">70</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#14-1-概率无向图模型"><span class="nav-number">1.</span> <span class="nav-text">14.1 概率无向图模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#14-1-1-模型定义"><span class="nav-number">1.1.</span> <span class="nav-text">14.1.1 模型定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-1-2-概率无向图模型的因子分解"><span class="nav-number">1.2.</span> <span class="nav-text">14.1.2 概率无向图模型的因子分解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-2-条件随机场的定义与形式"><span class="nav-number">2.</span> <span class="nav-text">14.2 条件随机场的定义与形式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#14-2-1-条件随机场的定义"><span class="nav-number">2.1.</span> <span class="nav-text">14.2.1 条件随机场的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-2-2-条件随机场的参数化形式"><span class="nav-number">2.2.</span> <span class="nav-text">14.2.2 条件随机场的参数化形式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-2-3-条件随机场的简化形式"><span class="nav-number">2.3.</span> <span class="nav-text">14.2.3 条件随机场的简化形式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-2-4-条件随机场的矩阵形式"><span class="nav-number">2.4.</span> <span class="nav-text">14.2.4 条件随机场的矩阵形式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-3-条件随机场的概率计算问题"><span class="nav-number">3.</span> <span class="nav-text">14.3 条件随机场的概率计算问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#14-3-1-前向-后向算法"><span class="nav-number">3.1.</span> <span class="nav-text">14.3.1 前向-后向算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-3-2-概率计算"><span class="nav-number">3.2.</span> <span class="nav-text">14.3.2 概率计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-3-3-期望值的计算"><span class="nav-number">3.3.</span> <span class="nav-text">14.3.3 期望值的计算</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-4-条件随机场的学习算法"><span class="nav-number">4.</span> <span class="nav-text">14.4 条件随机场的学习算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#14-4-1-改进的迭代尺度法"><span class="nav-number">4.1.</span> <span class="nav-text">14.4.1 改进的迭代尺度法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-4-2-拟牛顿法"><span class="nav-number">4.2.</span> <span class="nav-text">14.4.2 拟牛顿法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-5-条件随机场的预测算法"><span class="nav-number">5.</span> <span class="nav-text">14.5 条件随机场的预测算法</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jozee</span>

  
</div>
<div class="busuanzi_count">
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
    </script>
    <span> 本站访客数:<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
    <span>本站总访问量:<span id="busuanzi_value_site_pv"></span>次</span>
</div>









        






        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://jozeelin.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://jozeelin.github.io/2019/06/14/条件随机场/';
          this.page.identifier = '2019/06/14/条件随机场/';
          this.page.title = '条件随机场';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://jozeelin.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
